# ImitatorT 架构指导与开发规范

## 项目初衷

ImitatorT 是一个基于 Rust 的**轻量级多 Agent 公司模拟框架**，核心目标：

- 让多个 AI Agent 像真人一样在公司组织架构中协作
- Agent 可以自主决定发起私聊、创建群聊、执行任务
- 通过 YAML 配置即可定义公司和 Agent，无需编写代码

**这不是**：
- 企业级 IM 系统
- 复杂的 Web 应用框架
- 通用的 AI Agent 平台

---

## 架构红线（严禁违反）

### 1. 单一职责原则

**❌ 禁止**：
- Web 服务器直接管理业务逻辑生命周期
- 框架核心包含具体业务实现（如"哲学公司"硬编码角色）
- 领域层被应用层绕过

**✅ 正确**：
```
domain/     - 只定义实体：Agent、Message、Organization
core/       - 只提供能力：AgentRuntime、MessageBus
application/ - 编排逻辑：VirtualCompany、AutonomousAgent
infrastructure/ - 外部交互：LLMClient、Logger
```

### 2. DRY 原则（Don't Repeat Yourself）

**❌ 禁止**：
- Agent 定义在多个位置重复
- Message/Session 结构重复定义
- 两套并行的自主系统（autonomous/ 和 autonomous_v2/）

**✅ 正确**：
- `domain/agent.rs` 是 Agent 的**唯一真理来源**
- 其他层只能引用，不能重新定义

### 3. 框架与示例分离

**❌ 禁止**：
- Example 直接依赖框架内部实现
- 框架 API 只为特定 Example 设计
- Example 中的代码复制到框架核心

**✅ 正确**：
- Example 只通过 `lib.rs` 暴露的公共 API 使用框架
- 框架 API 设计先于 Example 实现
- Example 位于 `examples/` 目录，独立 Cargo 项目

### 4. 无状态优先

**❌ 禁止**：
- 在框架中引入复杂的数据库持久化
- Agent 状态与运行时强耦合
- 依赖特定存储实现的业务逻辑

**✅ 正确**：
- 默认使用内存存储
- 配置和状态通过外部文件传入
- 框架不管理数据生命周期

---

## 代码量控制

**硬性指标**：
- 核心框架代码（`src/`）不超过 5000 行
- 单个文件不超过 500 行
- 每个模块只保留一个实现（禁止 V1/V2 并行）

**达到红线时的处理方式**：
1. 删除而非修改（废弃代码直接删除，不要留注释）
2. 拆分到 Example（具体业务逻辑移到 examples/）
3. 简化设计（复杂功能先砍掉，需要时再加）

---

## 文件组织规范

### 目录结构

```
ImitatorT/
├── src/                    # 框架核心（精简）
│   ├── domain/            # 领域层：实体定义
│   ├── core/              # 核心层：运行时能力
│   ├── application/       # 应用层：编排逻辑
│   └── infrastructure/    # 基础设施：外部交互
├── frontend/              # 前端展示层（核心GUI）
│   ├── src/              # React + TypeScript 源码
│   ├── public/           # 静态资源
│   └── package.json      # npm 配置
├── examples/              # 示例项目（完全独立）
│   └── simple_company/    # 每个示例是一个独立 Cargo 项目
├── tmp/                   # 临时文件（必须被 .gitignore 忽略）
│   ├── screenshots/       # 测试截图
│   └── docs/             # 历史文档
├── CLAUDE.md             # 本文件：架构指导
├── README.md             # 项目介绍（必须简洁）
└── Cargo.toml
```

### 临时文件管理

**所有非核心代码必须放入 `tmp/` 目录**：
- 测试截图、图片
- 历史文档备份
- 生成文件、日志
- 实验性代码
- 前端项目备份

**`.gitignore` 必须包含**：
```
/target
.env
.DS_Store
tmp/           # 新增：忽略所有临时文件
```

---

## 重构教训（必读）

### 教训 1：过早抽象是万恶之源

**错误**：
- 项目初期就设计复杂的 A2A 协议层
- 为了"可能的扩展性"引入过多接口和 trait
- 试图同时支持内存存储、SQLite、sled 等多种后端

**后果**：
- 代码量增加 3 倍
- 理解成本极高
- 实际上只使用了一种存储

**正确做法**：
- 先实现最简单的版本（内存存储）
- 需要替换时再抽象接口
- 三个具体实现之前不要抽象

### 教训 2：演示代码污染核心

**错误**：
- 把"哲学公司"的 50+ 个硬编码角色放入 `im/mod.rs`
- 在框架核心初始化演示数据
- Web 服务器直接启动自主聊天引擎

**后果**：
- 框架无法独立使用
- 启动时必须加载大量无用数据
- 业务逻辑与框架深度耦合

**正确做法**：
- 演示数据放在 example 的配置文件中
- 框架只提供加载配置的接口
- Web 服务器与业务逻辑完全分离

### 教训 3：版本并存是技术债

**错误**：
- autonomous/ 和 autonomous_v2/ 同时存在
- 两套系统功能重叠但行为不同
- 新功能只在 V2 实现，但 V1 仍在使用

**后果**：
- 维护成本翻倍
- 行为不可预测
- 开发者不知道用哪个

**正确做法**：
- 重构时彻底删除旧版本
- 不要保留"暂时兼容"的代码
- 版本控制可以找回旧代码，不需要注释保留

### 教训 4：Example 应该驱动设计

**错误**：
- 先写框架 API，再写 Example
- Example 复制框架内部代码来实现功能
- Example 展示的是"框架能做什么"而非"用户想做什么"

**正确做法**：
1. 先写 Example（伪代码也可以）
2. 确保 Example 符合用户直觉
3. 根据 Example 设计框架 API
4. 实现框架使 Example 能运行

---

## 开发检查清单

每次提交前检查：

- [ ] 是否有重复定义的结构体？
- [ ] 是否有硬编码的业务逻辑？
- [ ] Example 是否只使用了公共 API（Example中的Tool除外，可以任意使用其他api）？
- [ ] 新增文件是否必要？
- [ ] 是否删除了无用代码（而非注释掉）？
- [ ] 测试是否通过？
- [ ] 文档是否同步更新？

---

## 重构触发条件

出现以下情况时必须重构：

1. 同一概念在 3 个以上地方定义
4. 出现两套实现并存
5. Example 无法使用框架 API 完成

**重构原则**：
- 删除优于修改
- 简单优于复杂
- 独立优于耦合

---

## 版本历史

- **v0.2** (2025-02-25): 彻底重构，代码量减少 90%，回归初衷
- **v0.1**: 过度设计，功能臃肿，成为"屎山"

---

## 参考

- [README.md](README.md) - 项目介绍
- [examples/simple_company/](examples/simple_company/) - 正确使用示例
